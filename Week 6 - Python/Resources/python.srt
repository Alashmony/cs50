1
00:00:00,000 --> 00:00:00,024


2
00:00:00,024 --> 00:00:02,940
DOUG LLOYD: As we continue to put C
in the rear view mirror behind us,

3
00:00:02,940 --> 00:00:05,481
I wanted to now introduce you
to another programming language

4
00:00:05,481 --> 00:00:07,023
that we'll use a lot in CS50, Python.

5
00:00:07,023 --> 00:00:09,939
Now, of course we're not going to
be able to cover Python in nearly as

6
00:00:09,939 --> 00:00:12,660
much depth as we spent in
those 30 or so videos we spent

7
00:00:12,660 --> 00:00:14,850
talking about C in prior
weeks, but the goal here

8
00:00:14,850 --> 00:00:17,160
is really to give you an
introduction to the language

9
00:00:17,160 --> 00:00:19,993
so you can see some of the tools
it has and figure out how you might

10
00:00:19,993 --> 00:00:21,750
want to use them best on your own.

11
00:00:21,750 --> 00:00:24,761
Now, Python is an example of a pretty
commonly used modern programming

12
00:00:24,761 --> 00:00:25,260
language.

13
00:00:25,260 --> 00:00:28,740
It's probably in the top five or six at
the time this video is being recorded.

14
00:00:28,740 --> 00:00:30,240
It's been around though for a while.

15
00:00:30,240 --> 00:00:32,520
It's been around for over
25 years, and it's really

16
00:00:32,520 --> 00:00:36,970
a great language choice for making some
complex operations in C a lot easier.

17
00:00:36,970 --> 00:00:40,530
So you may recall working with
C that string manipulation

18
00:00:40,530 --> 00:00:42,740
can be really challenging.

19
00:00:42,740 --> 00:00:45,180
And it also simplifies
things like networking

20
00:00:45,180 --> 00:00:47,867
and really it's a general
purpose utility language

21
00:00:47,867 --> 00:00:49,450
that you can use to do a lot of stuff.

22
00:00:49,450 --> 00:00:52,200
It's also very popular right
now among data scientists

23
00:00:52,200 --> 00:00:55,690
for processing large sets of data
and generating graphs, charts,

24
00:00:55,690 --> 00:00:57,510
and results from that.

25
00:00:57,510 --> 00:00:59,010
There is some good news too as well.

26
00:00:59,010 --> 00:01:03,060
So Python is pretty inspired by C as
a lot of modern programming languages

27
00:01:03,060 --> 00:01:04,940
are honestly.

28
00:01:04,940 --> 00:01:07,620
And its syntax is going to
look a little bit different,

29
00:01:07,620 --> 00:01:12,266
but it has some pretty consistent
look and feel things to it.

30
00:01:12,266 --> 00:01:15,390
You're not going to see as many curly
braces or anything like that that you

31
00:01:15,390 --> 00:01:17,850
didn't in C, but hopefully
some of the style

32
00:01:17,850 --> 00:01:21,277
lessons that you learned along the
way will come in handy for you here.

33
00:01:21,277 --> 00:01:23,735
To start writing a Python file
it's pretty straightforward.

34
00:01:23,735 --> 00:01:26,310
All you've got to do is open
up a file with the dot py

35
00:01:26,310 --> 00:01:28,296
file extension inside of CS50 IDE.

36
00:01:28,296 --> 00:01:30,420
That will automatically
syntax highlight it for you

37
00:01:30,420 --> 00:01:35,490
and show you that what you're typing
is proper valid Python or not.

38
00:01:35,490 --> 00:01:40,245
But unlike C, Python is
not a compiled language.

39
00:01:40,245 --> 00:01:43,050
Or it is not necessarily
a compiled language.

40
00:01:43,050 --> 00:01:46,320
Python programs can be run
in a Python interpreter.

41
00:01:46,320 --> 00:01:48,906
This is similar to PHP if you're
familiar with that language

42
00:01:48,906 --> 00:01:51,030
as well where you can just
write your lines of code

43
00:01:51,030 --> 00:01:55,740
and have the computer just run through
them one by one executing as you go.

44
00:01:55,740 --> 00:01:56,820


45
00:01:56,820 --> 00:01:59,640
Python programs can work
in exactly the same way.

46
00:01:59,640 --> 00:02:02,320
One really important caveat
before we dive into this.

47
00:02:02,320 --> 00:02:04,324
In CS50, we teach Python 3.

48
00:02:04,324 --> 00:02:06,240
There are actually two
pretty popular versions

49
00:02:06,240 --> 00:02:09,840
of Python, Python 2 and Python 3.

50
00:02:09,840 --> 00:02:12,840
So all the syntax and everything we're
going to talk about in this video

51
00:02:12,840 --> 00:02:16,380
is Python 3 specific,
and in general, if you're

52
00:02:16,380 --> 00:02:18,720
looking up documentation
on your own trying

53
00:02:18,720 --> 00:02:21,027
to figure out how to
use a Python function

54
00:02:21,027 --> 00:02:23,610
or figure out if there's a Python
function that does something

55
00:02:23,610 --> 00:02:28,616
you're looking to do, be sure to
include Python 3 in your search

56
00:02:28,616 --> 00:02:31,740
instead of just saying Python, because
you might get Python 2 results which

57
00:02:31,740 --> 00:02:34,174
would not necessarily work.

58
00:02:34,174 --> 00:02:36,840
So let's go through some of the
basic things that we can do in C

59
00:02:36,840 --> 00:02:39,150
and show you how we
can do them in Python.

60
00:02:39,150 --> 00:02:43,200
So variables have two
big differences from C.

61
00:02:43,200 --> 00:02:45,990
We don't have to specify a type
anymore so that's pretty cool.

62
00:02:45,990 --> 00:02:47,948
And we can declare them
only by initialization.

63
00:02:47,948 --> 00:02:50,040
So you may recall in C
that we could declare

64
00:02:50,040 --> 00:02:53,220
a variable by sayings for
example int x semicolon,

65
00:02:53,220 --> 00:02:56,130
but not actually assign a
value to it, not initialize it.

66
00:02:56,130 --> 00:02:59,100
In Python, we can only declare
variables by initializing them.

67
00:02:59,100 --> 00:03:03,630
So where in C we might say something
like this, int x equals 54 semicolon.

68
00:03:03,630 --> 00:03:07,980
In Python, we just say x equals 54
and that creates a new variable for us

69
00:03:07,980 --> 00:03:11,470
in Python called x and
assigns it the value 54.

70
00:03:11,470 --> 00:03:15,690
And notice here, Python statements
don't need to end with semicolons.

71
00:03:15,690 --> 00:03:18,360
So that might be a nice thing
if you're the kind of person who

72
00:03:18,360 --> 00:03:21,480
like me oftentimes will forget to
put a semicolon at the end of a line.

73
00:03:21,480 --> 00:03:23,280
In Python you don't
need to include them.

74
00:03:23,280 --> 00:03:25,420
You can include them and
it won't have a problem,

75
00:03:25,420 --> 00:03:29,730
but you can also omit them to make
your code look a little bit cleaner.

76
00:03:29,730 --> 00:03:33,750
Similarly, can we declare the following,
string phrase equals this is CS50,

77
00:03:33,750 --> 00:03:36,395
and to do this in C we
would have to pound include

78
00:03:36,395 --> 00:03:40,667
the CS50 library because string
is not a native data type in C.

79
00:03:40,667 --> 00:03:41,500
But it is in Python.

80
00:03:41,500 --> 00:03:44,502
We can just say, phrase
equals this is CS50.

81
00:03:44,502 --> 00:03:46,710
And in fact, we don't even
have to use double quotes.

82
00:03:46,710 --> 00:03:50,132
Python actually support strings
with double quotes or single quotes.

83
00:03:50,132 --> 00:03:51,840
And this is actually
really useful if you

84
00:03:51,840 --> 00:03:56,235
need to declare a string that
has quotation marks in it,

85
00:03:56,235 --> 00:03:58,110
you can just kind of
alternate back and forth

86
00:03:58,110 --> 00:04:01,500
between using single quotes on the
outside, double quotes on the inside,

87
00:04:01,500 --> 00:04:05,969
single quotes inside of that, and so
on, and that's actually kind of useful

88
00:04:05,969 --> 00:04:09,010
if you're the kind of person who's
working with a lot of text for example

89
00:04:09,010 --> 00:04:11,260
in particular with databases.

90
00:04:11,260 --> 00:04:14,173
The conditional statements from C
are all available for you to use,

91
00:04:14,173 --> 00:04:16,089
but they might look a
teeny bit different now.

92
00:04:16,089 --> 00:04:19,600
So whereas in C we might say something
like this, if y is less than 43,

93
00:04:19,600 --> 00:04:22,464
or z equals equals 15, and
then we have some code.

94
00:04:22,464 --> 00:04:24,130
That's not what it looks like in Python.

95
00:04:24,130 --> 00:04:26,630
It looks a little something like this.

96
00:04:26,630 --> 00:04:31,610
If y is less than 43 or
literally using the word or now,

97
00:04:31,610 --> 00:04:34,890
not using two vertical bars,
because in Python we can do that.

98
00:04:34,890 --> 00:04:38,950
Or z equals 15 colon,
instead of open curly brace

99
00:04:38,950 --> 00:04:44,670
and then whatever code we have close
curly brace and then some code below.

100
00:04:44,670 --> 00:04:48,160
In Python, all comments are
introduced with the pound sign or hash

101
00:04:48,160 --> 00:04:49,280
mark like this.

102
00:04:49,280 --> 00:04:53,480
So this basically just indicates
that this is a comment.

103
00:04:53,480 --> 00:04:55,880
So here's an if else statement
that might be familiar

104
00:04:55,880 --> 00:04:59,360
with from C. In Python, it's
going to look pretty similar.

105
00:04:59,360 --> 00:05:02,790
Again, it looks just
like this where we now--

106
00:05:02,790 --> 00:05:04,640
well actually, we have and here.

107
00:05:04,640 --> 00:05:09,319
So previously in C we have if y is
less than 43 and z is equal to 15.

108
00:05:09,319 --> 00:05:12,110
In Python, just like where or was
translated from two vertical bars

109
00:05:12,110 --> 00:05:18,020
to the word or, in Python
we've translated two ampersands

110
00:05:18,020 --> 00:05:18,890
to the word and.

111
00:05:18,890 --> 00:05:20,848
So we don't have to use
two ampersands anymore,

112
00:05:20,848 --> 00:05:22,700
we can just literally say the word and.

113
00:05:22,700 --> 00:05:24,020
Then we have the else there.

114
00:05:24,020 --> 00:05:25,970
The else is not that
big of a difference.

115
00:05:25,970 --> 00:05:27,720
This one is a little
bit different though.

116
00:05:27,720 --> 00:05:30,170
So if course number
equals 50 we do one thing.

117
00:05:30,170 --> 00:05:35,090
Else if course number is not
equal to 51 we do something else.

118
00:05:35,090 --> 00:05:42,004
In Python, we don't have else
if, we have elif, not elseif.

119
00:05:42,004 --> 00:05:44,170
But otherwise it's going
to behave exactly the same.

120
00:05:44,170 --> 00:05:48,430
So just again, trying to cut a couple of
characters out of what we have to type.

121
00:05:48,430 --> 00:05:53,440
And again, instead of using course
num not equal to 51, we can do elif

122
00:05:53,440 --> 00:05:55,780
not course num equals 51.

123
00:05:55,780 --> 00:05:59,860
Again, it's a little bit of a twist, but
we can again use these English words.

124
00:05:59,860 --> 00:06:03,430
We're not having to use the exclamation
point symbol, the vertical bar

125
00:06:03,430 --> 00:06:07,375
symbol, the ampersand, all that
sort of taking away that junk

126
00:06:07,375 --> 00:06:10,512
and we can just start to speak
English almost in Python.

127
00:06:10,512 --> 00:06:13,720
And that's actually one of the reasons
that people find this language popular

128
00:06:13,720 --> 00:06:17,620
is because generally, if you think you
want to write something in English,

129
00:06:17,620 --> 00:06:20,890
you're actually pretty much on the way
to writing it the same thing in Python.

130
00:06:20,890 --> 00:06:25,870
As I pointed out, we don't have else
if, it's just one word here, elif.

131
00:06:25,870 --> 00:06:29,140
Just like before though, we
end our lines now with colons

132
00:06:29,140 --> 00:06:30,520
and we indent our code blocks.

133
00:06:30,520 --> 00:06:32,650
And as we'll see a bit
later, indenting in Python

134
00:06:32,650 --> 00:06:36,450
is super, super, super important.

135
00:06:36,450 --> 00:06:39,200
We also have question mark
colon, the ternary operator.

136
00:06:39,200 --> 00:06:40,560
It looks a little bit different.

137
00:06:40,560 --> 00:06:42,320
I'm going to show it
here just you see it,

138
00:06:42,320 --> 00:06:45,200
but generally it's a little
bit weird so you might not

139
00:06:45,200 --> 00:06:46,762
use it all that frequently.

140
00:06:46,762 --> 00:06:49,220
So here what we're doing is
we're getting a character in C,

141
00:06:49,220 --> 00:06:53,360
and then if that character is a letter,
alphabetic gets assigned to the value

142
00:06:53,360 --> 00:06:56,480
true, otherwise it gets
assigned to the value false.

143
00:06:56,480 --> 00:06:59,010
Here, that line would look like this.

144
00:06:59,010 --> 00:07:03,290
It's a single line of code,
and we have our true and false.

145
00:07:03,290 --> 00:07:05,582
Notice that they are now
capitalized as opposed to in C

146
00:07:05,582 --> 00:07:06,623
where they're lower case.

147
00:07:06,623 --> 00:07:08,870
Again, these little syntax
differences are the kinds

148
00:07:08,870 --> 00:07:10,470
of things that when you're
learning a new language,

149
00:07:10,470 --> 00:07:13,390
these are the things that will vary a
little bit from language to language.

150
00:07:13,390 --> 00:07:15,560
But it's the general concepts
here that we're concerned with

151
00:07:15,560 --> 00:07:17,600
and these will become
second nature to you

152
00:07:17,600 --> 00:07:21,290
pretty quickly if you use Python
for more than a week or so.

153
00:07:21,290 --> 00:07:23,510
We have this function called
input, which we can use.

154
00:07:23,510 --> 00:07:24,810
It's native to Python.

155
00:07:24,810 --> 00:07:27,710
And we can use that to collect
user input at the command line,

156
00:07:27,710 --> 00:07:32,491
just like we did in CS50's library
with get char, get float, get int,

157
00:07:32,491 --> 00:07:32,990
and so on.

158
00:07:32,990 --> 00:07:34,430
Although those functions,
again, are also

159
00:07:34,430 --> 00:07:35,888
available for you to use in Python.

160
00:07:35,888 --> 00:07:40,490
We rewrote them in Python for you.

161
00:07:40,490 --> 00:07:42,720
We have two kinds of loops in Python.

162
00:07:42,720 --> 00:07:43,730
So in C we had three.

163
00:07:43,730 --> 00:07:46,472
We had while loops, do
while loops, and for loops.

164
00:07:46,472 --> 00:07:48,680
Here in Python, we don't
have do while loops anymore.

165
00:07:48,680 --> 00:07:51,470
We only have the two, while
and for, although they're

166
00:07:51,470 --> 00:07:53,450
a bit more flexible here.

167
00:07:53,450 --> 00:07:56,580
So here's an example of some C code
where we're using a while loop.

168
00:07:56,580 --> 00:07:58,910
We initialize a counter
to 0, and then so long

169
00:07:58,910 --> 00:08:02,986
as that counter is less than
100, we print out the number

170
00:08:02,986 --> 00:08:04,610
and then we increment the counter by 1.

171
00:08:04,610 --> 00:08:08,563
So this loop will run 100 times,
printing the numbers 0 1 dot, dot, dot,

172
00:08:08,563 --> 00:08:10,870
dot, dot all the way down to 99.

173
00:08:10,870 --> 00:08:14,060
Do this same thing in Python, it would
look a little something like this.

174
00:08:14,060 --> 00:08:16,610
Counter equals zero-- again, we're
leaving off the type specifier

175
00:08:16,610 --> 00:08:18,193
because it's Python, we don't need it.

176
00:08:18,193 --> 00:08:20,060
There's no semicolons at the end.

177
00:08:20,060 --> 00:08:22,310
And then while counter
is less than 100-- again,

178
00:08:22,310 --> 00:08:24,140
no extraneous parentheses here either.

179
00:08:24,140 --> 00:08:27,020
We're really trying to
streamline what we can.

180
00:08:27,020 --> 00:08:30,765
Then we just print out the counter
and we say, counter plus equals 1.

181
00:08:30,765 --> 00:08:33,400
This is another catch here in Python.

182
00:08:33,400 --> 00:08:36,230
Plus plus is not the
increment by one operator.

183
00:08:36,230 --> 00:08:39,500
We have to very explicitly
call out counter plus equals 1.

184
00:08:39,500 --> 00:08:41,309
We can't say counter plus plus.

185
00:08:41,309 --> 00:08:43,475
But otherwise, this would
do exactly the same thing.

186
00:08:43,475 --> 00:08:48,320
Print out one line at a
time the numbers 0 to 99.

187
00:08:48,320 --> 00:08:51,560
And notice also that we don't have
to include that backslash n that we

188
00:08:51,560 --> 00:08:53,390
did in C when we were using printf.

189
00:08:53,390 --> 00:08:56,410
In Python, by default it assumes
that if you're printing something,

190
00:08:56,410 --> 00:08:59,820
it's just going to tack a new line on
at the very end for you automatically.

191
00:08:59,820 --> 00:09:01,276
So that's kind of nice.

192
00:09:01,276 --> 00:09:03,650
Here's a for loop that would
do again pretty much exactly

193
00:09:03,650 --> 00:09:04,983
the same thing that we just saw.

194
00:09:04,983 --> 00:09:09,319
It initializes the variable x to 0,
and then so long as x is less than 100

195
00:09:09,319 --> 00:09:11,360
it will print out the
number, and then at the end

196
00:09:11,360 --> 00:09:14,330
of every iteration of the loop it
will execute the line x plus plus.

197
00:09:14,330 --> 00:09:19,010
So we'll again have 0 1 dot, dot,
dot, dot, dot all the way down to 99.

198
00:09:19,010 --> 00:09:21,470
In Python it looks a
little something like this.

199
00:09:21,470 --> 00:09:25,580
For x in range 1000 print x.

200
00:09:25,580 --> 00:09:28,394
So range is a function that
will give us basically a list,

201
00:09:28,394 --> 00:09:31,310
and we'll talk about what that is
in just a moment, of all the numbers

202
00:09:31,310 --> 00:09:33,740
from 0 to 100 but not including 100.

203
00:09:33,740 --> 00:09:35,724
So this would give us a list of 0 to 99.

204
00:09:35,724 --> 00:09:38,390
And then we're just going to print
out every number in that list

205
00:09:38,390 --> 00:09:40,820
starting at the beginning,
going all the way to the end.

206
00:09:40,820 --> 00:09:43,370
In a for loop where we
wanted to count by twos

207
00:09:43,370 --> 00:09:45,219
we might do something like this.

208
00:09:45,219 --> 00:09:47,010
In Python we can also
do that, we just have

209
00:09:47,010 --> 00:09:50,870
to add one extra parameter
to our range function.

210
00:09:50,870 --> 00:09:54,290
We set a start point, we
set with the endpoint,

211
00:09:54,290 --> 00:09:57,020
and we set how much we want to skip by.

212
00:09:57,020 --> 00:10:00,410
So this is a list of all of
the integers from up to 100

213
00:10:00,410 --> 00:10:03,570
but not counting 100, counting by twos.

214
00:10:03,570 --> 00:10:08,350
So this would generate a list for us
of 0, 2, 4, 6, 8 and so on all the way

215
00:10:08,350 --> 00:10:11,080
up to 98.

216
00:10:11,080 --> 00:10:12,400
So arrays.

217
00:10:12,400 --> 00:10:14,380
So arrays are really
where Python is going

218
00:10:14,380 --> 00:10:16,810
to start to shine and show us
some of the real advantages

219
00:10:16,810 --> 00:10:20,407
it has over a language like C, which
is a little more constricted in what

220
00:10:20,407 --> 00:10:22,240
it can do with arrays
because of two things.

221
00:10:22,240 --> 00:10:26,650
One, they're fixed size, and two, we
can only store one type of variable

222
00:10:26,650 --> 00:10:27,370
in them.

223
00:10:27,370 --> 00:10:30,610
We can only store an array of
all integers, all characters, all

224
00:10:30,610 --> 00:10:33,310
some structure that
we created, and so on.

225
00:10:33,310 --> 00:10:35,410
In Python, we don't
actually call them arrays.

226
00:10:35,410 --> 00:10:39,010
We call them lists, but they're
effectively the same general idea,

227
00:10:39,010 --> 00:10:41,200
the same concept we're familiar with.

228
00:10:41,200 --> 00:10:42,550
They're not fixed in size.

229
00:10:42,550 --> 00:10:46,570
So similar to a linked list really we
can grow and shrink them as we need,

230
00:10:46,570 --> 00:10:48,970
as our program demands
more memory or less memory

231
00:10:48,970 --> 00:10:52,060
to be consumed by the list the
language is flexible enough

232
00:10:52,060 --> 00:10:53,890
to allow us to do that.

233
00:10:53,890 --> 00:10:58,180
And we can always add more things on,
splice or remove things from the middle

234
00:10:58,180 --> 00:10:59,540
pretty easily.

235
00:10:59,540 --> 00:11:02,530
So let's get in the habit of calling
these things lists now instead

236
00:11:02,530 --> 00:11:03,726
of arrays.

237
00:11:03,726 --> 00:11:06,100
But to declare a list it's
really pretty straightforward.

238
00:11:06,100 --> 00:11:08,811
Nums equals square brackets.

239
00:11:08,811 --> 00:11:09,310
There we go.

240
00:11:09,310 --> 00:11:09,809
We have it.

241
00:11:09,809 --> 00:11:13,050
That's an empty list or an empty array.

242
00:11:13,050 --> 00:11:15,970
But that's all we really
need to do to do it.

243
00:11:15,970 --> 00:11:19,660
We could create a list that has a couple
of elements pre-populated into it.

244
00:11:19,660 --> 00:11:22,420
Nums equals 1, 2, 3, 4.

245
00:11:22,420 --> 00:11:27,160
That is an explicitly created list.

246
00:11:27,160 --> 00:11:30,160
Python also has support for something
called a list comprehension, which

247
00:11:30,160 --> 00:11:31,970
we're not going to get into
in a lot of detail here,

248
00:11:31,970 --> 00:11:33,720
but I want to show you
what it looks like.

249
00:11:33,720 --> 00:11:37,720
Nums equals x, and then
I have a for loop inside

250
00:11:37,720 --> 00:11:40,102
of my declaration of my list.

251
00:11:40,102 --> 00:11:43,060
This is called the list comprehension,
and basically what this is doing

252
00:11:43,060 --> 00:11:47,520
is I'm using the for loop to
generate a list of numbers for me.

253
00:11:47,520 --> 00:11:50,770
And instead of doing anything with that
list like where I as printing them out

254
00:11:50,770 --> 00:11:54,010
before, I'm using that
list that the for loop

255
00:11:54,010 --> 00:11:57,620
generates to assign it to nums instead.

256
00:11:57,620 --> 00:12:01,840
So what this would do is create
a list of 500 elements, all

257
00:12:01,840 --> 00:12:05,470
of the numbers up from
0 all the way up to 499,

258
00:12:05,470 --> 00:12:08,530
because again range excludes
that final parameter.

259
00:12:08,530 --> 00:12:10,600
So we're not including 500.

260
00:12:10,600 --> 00:12:15,980
Our range has 500 things in it, but
it's going from 0 to 499, not 0 to 500

261
00:12:15,980 --> 00:12:19,190
which would be 501 things in the list.

262
00:12:19,190 --> 00:12:21,100
Now, instead of the
square bracket syntax,

263
00:12:21,100 --> 00:12:23,882
there's also just saying nums
equals list parentheses, which

264
00:12:23,882 --> 00:12:26,590
is a function that creates a list,
and if you don't pass anything

265
00:12:26,590 --> 00:12:29,990
in it returns an empty list or
an empty set of square brackets.

266
00:12:29,990 --> 00:12:32,980
So that's exactly the same as
what we saw just a moment ago

267
00:12:32,980 --> 00:12:34,957
with the blank empty list.

268
00:12:34,957 --> 00:12:36,040
Now we have the following.

269
00:12:36,040 --> 00:12:38,190
We could say nums equals 1, 2, 3, 4.

270
00:12:38,190 --> 00:12:40,930
So that's explicitly creating
a list of four elements.

271
00:12:40,930 --> 00:12:43,330
We can attach an element
to the end of the list.

272
00:12:43,330 --> 00:12:46,070
We can say, nums dot append 5.

273
00:12:46,070 --> 00:12:49,990
And what that's going to do is that's
going to add 5 to the end of the list.

274
00:12:49,990 --> 00:12:52,570
It's going to tack it
on at the very end.

275
00:12:52,570 --> 00:12:55,120
This line of code would
do exactly the same thing.

276
00:12:55,120 --> 00:12:57,577
Nums dot insert parentheses 4 comma 5.

277
00:12:57,577 --> 00:12:58,660
Well, what does this mean?

278
00:12:58,660 --> 00:13:02,620
Well, what's happening here is we're
inserting in the fourth position,

279
00:13:02,620 --> 00:13:05,200
again counting from
0, and if you remember

280
00:13:05,200 --> 00:13:09,910
how we count in C we know that 1
here is in the zeroth position,

281
00:13:09,910 --> 00:13:13,450
2 is in the first position,
3 is in the second position,

282
00:13:13,450 --> 00:13:14,829
4 is in the third position.

283
00:13:14,829 --> 00:13:16,870
So what we're doing here
is really just inserting

284
00:13:16,870 --> 00:13:20,240
into the fourth position the value 5.

285
00:13:20,240 --> 00:13:23,570
So this line, and this one that we
just saw do exactly the same thing.

286
00:13:23,570 --> 00:13:27,430
They put a 5 at the end of that array.

287
00:13:27,430 --> 00:13:29,770
This also does the same thing.

288
00:13:29,770 --> 00:13:34,994
Nums square bracket len
nums colon 5 equals 5.

289
00:13:34,994 --> 00:13:37,660
Little bit weirder, but basically
what we're doing here is we're

290
00:13:37,660 --> 00:13:42,790
creating another list
effectively, and we're splicing it

291
00:13:42,790 --> 00:13:45,190
on to the one that exists before.

292
00:13:45,190 --> 00:13:47,270
So what I'm saying is,
I'm creating a new list.

293
00:13:47,270 --> 00:13:50,590
There's a list there
with a single element, 5.

294
00:13:50,590 --> 00:13:56,320
And I'm saying, the nums list from
position 4, which is the length of nums

295
00:13:56,320 --> 00:13:59,130
forward, gets this list assigned to it.

296
00:13:59,130 --> 00:14:02,890
So if i had put 5 comma 6
there, after this would execute

297
00:14:02,890 --> 00:14:06,550
I would end up with nums
equals 1, 2, 3, 4, 5, 6.

298
00:14:06,550 --> 00:14:10,456
So this is how I can
perhaps attach one list

299
00:14:10,456 --> 00:14:12,580
to the end of another list,
as opposed to attaching

300
00:14:12,580 --> 00:14:17,480
one element to the end of a list.

301
00:14:17,480 --> 00:14:21,542
So len nums works just like strlen might
if you're familiar with that from C.

302
00:14:21,542 --> 00:14:23,000
It calculates the length of a list.

303
00:14:23,000 --> 00:14:25,960
So len now becomes a
function in Python that

304
00:14:25,960 --> 00:14:29,630
is usable to calculate not
just the length of a string,

305
00:14:29,630 --> 00:14:32,570
but the length of any arbitrary list.

306
00:14:32,570 --> 00:14:34,910
Kind of useful.

307
00:14:34,910 --> 00:14:37,180
All right, here's a new
data type that we've never--

308
00:14:37,180 --> 00:14:39,200
or a new kind of way of
storing data in Python

309
00:14:39,200 --> 00:14:42,440
that we're not familiar with
from C and that's called a tuple.

310
00:14:42,440 --> 00:14:47,870
So what a tuple is, it is an
ordered, immutable set of data,

311
00:14:47,870 --> 00:14:52,310
basically what we're saying here is we
have a collection of a couple of things

312
00:14:52,310 --> 00:14:56,730
that we will never change,
but the order matters.

313
00:14:56,730 --> 00:15:00,137
And we'll take a look at an example
in just a moment of what a tuple might

314
00:15:00,137 --> 00:15:02,220
look like or what a list
of tuples might look like

315
00:15:02,220 --> 00:15:04,230
and why we might want to work them.

316
00:15:04,230 --> 00:15:06,930
But they're really good for
associating collections of data.

317
00:15:06,930 --> 00:15:10,070
They're really fast
to navigate in Python.

318
00:15:10,070 --> 00:15:13,320
And they're really kind of analogous to
a structure in C where the values will

319
00:15:13,320 --> 00:15:15,930
never change, but you've
arranged them because of the way

320
00:15:15,930 --> 00:15:19,930
you arranged your fields
in C in a particular order.

321
00:15:19,930 --> 00:15:22,500
So here, for example is a list--

322
00:15:22,500 --> 00:15:24,330
so a list which we just talked about--

323
00:15:24,330 --> 00:15:25,870
of tuples.

324
00:15:25,870 --> 00:15:28,200
So we're mixing these two
concepts together here.

325
00:15:28,200 --> 00:15:29,910
Here is a list of tuples.

326
00:15:29,910 --> 00:15:34,920
This is a list called presidents
that contains four tuples,

327
00:15:34,920 --> 00:15:37,720
George Washington comma
1789 in parentheses--

328
00:15:37,720 --> 00:15:39,780
that's how we indicate a tuple--

329
00:15:39,780 --> 00:15:43,120
John Adams comma 1797,
and so on and so on.

330
00:15:43,120 --> 00:15:48,390
Each of these, each of George Washington
1789 and John Adams 1797 and so on,

331
00:15:48,390 --> 00:15:49,980
that is a single tuple.

332
00:15:49,980 --> 00:15:52,980
And then you see here that we have
the commas at the end of those tuples

333
00:15:52,980 --> 00:15:58,320
to indicate that all of those are items
in the larger list called presidents.

334
00:15:58,320 --> 00:16:02,252
Now, we can iterate over this
list and do things with it.

335
00:16:02,252 --> 00:16:04,710
So let's take a look at an
example of how we might do that.

336
00:16:04,710 --> 00:16:10,450
So up at the top right is our presidents
list from just the previous slide.

337
00:16:10,450 --> 00:16:12,420
And I can do the following.

338
00:16:12,420 --> 00:16:15,660
For prez comma year in presidents.

339
00:16:15,660 --> 00:16:18,510
So now, notice, I'm not
just saying for x in range

340
00:16:18,510 --> 00:16:26,309
where I'm using one iterator,
I have two, prez comma year.

341
00:16:26,309 --> 00:16:28,350
And if you look, you'll
notice that that actually

342
00:16:28,350 --> 00:16:31,630
matches what I have there
in the presidents list.

343
00:16:31,630 --> 00:16:39,270
I have a set of four tuples where
each is arranged prez comma year.

344
00:16:39,270 --> 00:16:40,680
Then I'm doing something weird.

345
00:16:40,680 --> 00:16:42,850
Print in square bracket--

346
00:16:42,850 --> 00:16:47,970
in curly brackets 1 curly bracket
0 took office dot format prez year.

347
00:16:47,970 --> 00:16:49,440
What is happening?

348
00:16:49,440 --> 00:16:52,020
This is actually just how
the print function in Python

349
00:16:52,020 --> 00:16:57,360
does what printf does in C. Instead of
using percent s or percent c or percent

350
00:16:57,360 --> 00:17:00,570
d, those format specifiers
that we're used to from C,

351
00:17:00,570 --> 00:17:05,240
here we use the dot
format method, which we'll

352
00:17:05,240 --> 00:17:09,896
talk about again in just a moment,
at the end of the print function.

353
00:17:09,896 --> 00:17:13,020
And we can specify the order in which
we want those parameters to come out.

354
00:17:13,020 --> 00:17:16,660
So the 1 and 0 there match like this.

355
00:17:16,660 --> 00:17:19,116
Now granted, I wrote this
deliberately to show you

356
00:17:19,116 --> 00:17:20,490
that I could rearrange this list.

357
00:17:20,490 --> 00:17:23,339
I also could have just
swapped prez and year

358
00:17:23,339 --> 00:17:25,819
and I wouldn't need the numbers at all.

359
00:17:25,819 --> 00:17:27,569
If you leave them out
it will just go left

360
00:17:27,569 --> 00:17:32,280
to right through whatever the arguments
are to format and plug those in left

361
00:17:32,280 --> 00:17:35,850
to right just to fill in all
of the curly brace emptiness's

362
00:17:35,850 --> 00:17:37,350
that you have in the print function.

363
00:17:37,350 --> 00:17:40,360
But here, I can also explicitly
take them out of order if I want it.

364
00:17:40,360 --> 00:17:42,100
So that's all I'm doing here.

365
00:17:42,100 --> 00:17:44,220
I'm getting a list.

366
00:17:44,220 --> 00:17:46,880
I'm getting a single
tuple from this list

367
00:17:46,880 --> 00:17:52,950
and I'm basically printing its elements
in reverse order plugging them in.

368
00:17:52,950 --> 00:17:55,860
So again, a contrived example,
but I deliberately put

369
00:17:55,860 --> 00:17:58,900
it here to show you the
flexibility of the print function

370
00:17:58,900 --> 00:18:01,140
and to introduced several
concepts to you at once

371
00:18:01,140 --> 00:18:03,840
because you also are probably
going to see a lot of things

372
00:18:03,840 --> 00:18:06,381
like this when you're doing
research and trying to figure out

373
00:18:06,381 --> 00:18:07,680
what Python functions to use.

374
00:18:07,680 --> 00:18:10,679
You'll see a lot of unfamiliar things
sort of blending together at once.

375
00:18:10,679 --> 00:18:14,130
So I wanted to just kind of
introduce it to you here as well.

376
00:18:14,130 --> 00:18:17,620
But you can probably guess
what this is going to do.

377
00:18:17,620 --> 00:18:19,380
It'll print out the following.

378
00:18:19,380 --> 00:18:23,692
In 1789 George Washington took
office, In 1797 John Adams

379
00:18:23,692 --> 00:18:24,650
took office, and so on.

380
00:18:24,650 --> 00:18:26,880
It's going to iterate through
the list and print out

381
00:18:26,880 --> 00:18:28,890
each tuple plugging in its values.

382
00:18:28,890 --> 00:18:32,340
And because I have the 1 and 0 there
as opposed to just leaving them blank,

383
00:18:32,340 --> 00:18:34,700
it swaps the order of them.

384
00:18:34,700 --> 00:18:36,880
OK?

385
00:18:36,880 --> 00:18:39,599
Another thing that we're
sort of familiar with in C,

386
00:18:39,599 --> 00:18:41,890
although it's not native, we
had to build it ourselves,

387
00:18:41,890 --> 00:18:43,435
is the concept of a dictionary.

388
00:18:43,435 --> 00:18:48,707
Now dictionary is generally close in
spirit to the concept of a hash table.

389
00:18:48,707 --> 00:18:50,790
And remember that hash
tables were not native to C

390
00:18:50,790 --> 00:18:53,350
although they are native to a
lot of programming languages.

391
00:18:53,350 --> 00:18:55,750
We had to build it ourselves.

392
00:18:55,750 --> 00:18:59,650
So it allows us to associate
indexes with keys as opposed

393
00:18:59,650 --> 00:19:01,930
to integers, which we
had to do in C. So if we

394
00:19:01,930 --> 00:19:04,150
wanted to have, for example,
an array of something,

395
00:19:04,150 --> 00:19:06,970
we could only refer to
the elements of the array

396
00:19:06,970 --> 00:19:11,650
by an index number, array square bracket
0, array square bracket 1, and so on.

397
00:19:11,650 --> 00:19:15,700
In Python, we can now
associate elements of a list

398
00:19:15,700 --> 00:19:21,550
or elements in this case of a dictionary
with keywords as opposed to integers.

399
00:19:21,550 --> 00:19:26,390
So for example, here is
a dictionary of pizzas.

400
00:19:26,390 --> 00:19:29,010
So again, familiarize yourself
with the different types

401
00:19:29,010 --> 00:19:30,010
of brackets we're using.

402
00:19:30,010 --> 00:19:32,110
So remember, in lists
we have square brackets

403
00:19:32,110 --> 00:19:35,020
to indicate the beginning
and end of a list.

404
00:19:35,020 --> 00:19:39,550
In tuples we use parentheses to indicate
the beginning and end of a tuple.

405
00:19:39,550 --> 00:19:41,590
In dictionaries we use
curly braces to indicate

406
00:19:41,590 --> 00:19:44,200
the beginning and end of a dictionary.

407
00:19:44,200 --> 00:19:48,070
Inside of this pizza dictionary
I have four key value pairs.

408
00:19:48,070 --> 00:19:51,940
I associate the key
cheese with the value 9,

409
00:19:51,940 --> 00:19:56,592
I associate the key peperoni
with the value 10, and so on.

410
00:19:56,592 --> 00:19:58,300
Now, how might we want
to work with this?

411
00:19:58,300 --> 00:20:00,220
These again are out keys.

412
00:20:00,220 --> 00:20:03,250
We use a colon to separate
the key value pair.

413
00:20:03,250 --> 00:20:07,600
And we specify-- and those
are our values here in green.

414
00:20:07,600 --> 00:20:13,240
I can change the value of different key
value pairs in the dictionary as well.

415
00:20:13,240 --> 00:20:16,690
So I could say pizzas square
bracket cheese equals 8,

416
00:20:16,690 --> 00:20:22,030
and now the key cheese is not associated
with 9, it's associated with 8.

417
00:20:22,030 --> 00:20:26,230
I could use the different
keys in my dictionary

418
00:20:26,230 --> 00:20:27,880
in Boolean expressions like this.

419
00:20:27,880 --> 00:20:31,420
If pizza square bracket vegetables
is less than 12 I could do something.

420
00:20:31,420 --> 00:20:33,460
I can also add new
keys to the dictionary,

421
00:20:33,460 --> 00:20:37,670
key value pairs the dictionary,
without having to do anything crazy.

422
00:20:37,670 --> 00:20:41,690
Pizzas bacon, that key didn't
exist before, equals 14.

423
00:20:41,690 --> 00:20:44,770
Now we have a dictionary that has
five different key value pairs in it.

424
00:20:44,770 --> 00:20:47,820
Again, pretty straightforward to do.

425
00:20:47,820 --> 00:20:50,080
But we've introduced a new problem.

426
00:20:50,080 --> 00:20:54,902
If we don't have integer based
indexes like we did in C,

427
00:20:54,902 --> 00:20:56,610
how do we iterate
through the dictionary?

428
00:20:56,610 --> 00:20:58,670
We can't just iterate over the--

429
00:20:58,670 --> 00:21:01,170
I guess we could maybe iterate
over the keys alphabetically,

430
00:21:01,170 --> 00:21:03,295
but then we would have to
sort them alphabetically.

431
00:21:03,295 --> 00:21:05,820
That feels kind of messy.

432
00:21:05,820 --> 00:21:08,280
Fortunately, we can do
this, and it's because

433
00:21:08,280 --> 00:21:09,750
of the flexibility of the for loop.

434
00:21:09,750 --> 00:21:11,100
And I pointed that out to
you a little bit earlier

435
00:21:11,100 --> 00:21:14,224
and I said we'd come back to talk about
how the for loop was more flexible.

436
00:21:14,224 --> 00:21:16,210
Let's see an example of this.

437
00:21:16,210 --> 00:21:21,300
So the for loop is not just used to
count from one number up to another.

438
00:21:21,300 --> 00:21:26,890
We can also use it to iterate
over the elements of a dictionary.

439
00:21:26,890 --> 00:21:30,840
So instead of saying for x in range
500, which is going to do something

440
00:21:30,840 --> 00:21:36,237
500 times, I can say for pie in pizzas.

441
00:21:36,237 --> 00:21:37,320
That's pretty cool, right?

442
00:21:37,320 --> 00:21:39,528
So what it's going to do
there is it's going to use--

443
00:21:39,528 --> 00:21:41,250
pie basically becomes every single key.

444
00:21:41,250 --> 00:21:46,110
So cheese, bacon, vegetable, pepperoni,
whatever else I had in there, that's

445
00:21:46,110 --> 00:21:49,110
how we iterate over all
of those keys in Python

446
00:21:49,110 --> 00:21:54,850
without having the value of
integers that we did previously.

447
00:21:54,850 --> 00:21:58,080
So for example, here's the
original pizzas dictionary

448
00:21:58,080 --> 00:21:59,730
that we had just a moment ago.

449
00:21:59,730 --> 00:22:04,530
If I say for pie in pizzas print pie,
because again pie is substituting

450
00:22:04,530 --> 00:22:07,410
for the keys, this is going
to print out for me a list

451
00:22:07,410 --> 00:22:09,660
of all of the keys in my dictionary.

452
00:22:09,660 --> 00:22:13,770
So these are maybe the kinds of
pizzas that I have available.

453
00:22:13,770 --> 00:22:18,630
Or for pie comma price
in pizzas dot items-- now

454
00:22:18,630 --> 00:22:21,930
I have to specify pizzas
items here to make it

455
00:22:21,930 --> 00:22:24,330
so that it can iterate
over all of the keys.

456
00:22:24,330 --> 00:22:26,040
Excuse me, over all of the values.

457
00:22:26,040 --> 00:22:29,070
I can iterate over all of the keys
automatically in a dictionary.

458
00:22:29,070 --> 00:22:30,810
But if I want to
iterate over the values,

459
00:22:30,810 --> 00:22:35,400
I have to transform the
dictionary into a list.

460
00:22:35,400 --> 00:22:39,180
In order to do that, I
need to use the dot items

461
00:22:39,180 --> 00:22:41,970
method to transform my dictionary
into a list for purposes

462
00:22:41,970 --> 00:22:43,450
of just iterating over this.

463
00:22:43,450 --> 00:22:44,770
Then I can print out the price.

464
00:22:44,770 --> 00:22:50,519
So in this case, I would
print out 12, 10, 9, 11.

465
00:22:50,519 --> 00:22:51,060
That's weird.

466
00:22:51,060 --> 00:22:52,690
It didn't print them out
in the order I specified

467
00:22:52,690 --> 00:22:55,106
and that's kind of a side
effect here with the dictionary.

468
00:22:55,106 --> 00:22:57,180
You're not necessarily
going to get your--

469
00:22:57,180 --> 00:23:00,587
when you transform the dictionary into
a list to iterate over it as we do here,

470
00:23:00,587 --> 00:23:03,420
you're not guaranteed that that
list is going to maintain its order.

471
00:23:03,420 --> 00:23:06,810
Now, the keys and values will
still be associated correctly,

472
00:23:06,810 --> 00:23:10,350
if I wanted to print out both
as we'll see in just a second.

473
00:23:10,350 --> 00:23:12,280
But the order is not guaranteed anymore.

474
00:23:12,280 --> 00:23:14,290
Now usually that's not
going to be a problem.

475
00:23:14,290 --> 00:23:15,405
Sometimes it might be, in
which case you're just going

476
00:23:15,405 --> 00:23:17,840
to have to use a list at the outset.

477
00:23:17,840 --> 00:23:20,320
And there are, of
course, ways around it.

478
00:23:20,320 --> 00:23:23,280
Let's say I wanted to print
both the key and the value.

479
00:23:23,280 --> 00:23:25,680
It's very similar to
what I just had before.

480
00:23:25,680 --> 00:23:29,130
I'm still iterating over
pie and price, and I'm still

481
00:23:29,130 --> 00:23:31,710
transforming the pizzas
dictionary into a list

482
00:23:31,710 --> 00:23:34,340
temporarily so I can iterate over it.

483
00:23:34,340 --> 00:23:36,090
And I'm using my print
function again here

484
00:23:36,090 --> 00:23:38,880
with now I'm not specifying 0 and 1.

485
00:23:38,880 --> 00:23:42,880
I could, and specify 0 in the
first one, 1 in the second one.

486
00:23:42,880 --> 00:23:45,930
But I want to actually print
the key first then the value.

487
00:23:45,930 --> 00:23:49,634
I don't want to have to invert them so
I don't have to plug in the ordering

488
00:23:49,634 --> 00:23:52,050
that I did before when I was
doing the presidents example,

489
00:23:52,050 --> 00:23:53,383
iterating over all those tuples.

490
00:23:53,383 --> 00:23:54,360


491
00:23:54,360 --> 00:23:57,480
And this would print out, a
whole Buffalo chicken pizza

492
00:23:57,480 --> 00:24:00,570
costs $12, a whole
cheese pizza costs $9.

493
00:24:00,570 --> 00:24:05,040
Again, going through each element
and getting the key value pair

494
00:24:05,040 --> 00:24:07,260
and printing it out as I indicated.

495
00:24:07,260 --> 00:24:09,966
So that's how I can iterate
over an entire dictionary,

496
00:24:09,966 --> 00:24:11,340
printing out all of its elements.

497
00:24:11,340 --> 00:24:13,980
Again, with the caveat
that it's not ordered,

498
00:24:13,980 --> 00:24:17,220
so I'm not guaranteed to get them in
exactly the same order I put them in.

499
00:24:17,220 --> 00:24:22,490
But again, that trade off is probably
going to be worth it most of the time.

500
00:24:22,490 --> 00:24:25,244
So now we've seen a lot
of examples of this.

501
00:24:25,244 --> 00:24:27,410
How to interpolate variables
similar to printf where

502
00:24:27,410 --> 00:24:29,540
we would use percent substitution.

503
00:24:29,540 --> 00:24:31,910
In Python, we've seen this
one quite a few times.

504
00:24:31,910 --> 00:24:35,890
There's also this one which would allow
us to concatenate strings together.

505
00:24:35,890 --> 00:24:37,640
So here, I'm not doing
any interprolation,

506
00:24:37,640 --> 00:24:43,160
but I'm plugging in the variable
pie and the variable price,

507
00:24:43,160 --> 00:24:46,100
transforming it into a string,
because everything else here

508
00:24:46,100 --> 00:24:48,683
is the string so I need to
transform that number into a string

509
00:24:48,683 --> 00:24:50,450
to make this work correctly.

510
00:24:50,450 --> 00:24:52,430
So that's what the str
function there does.

511
00:24:52,430 --> 00:24:54,140
But this again would work.

512
00:24:54,140 --> 00:25:00,240
So a whole cheese pizza costs
dollars 9 turned into a string.

513
00:25:00,240 --> 00:25:03,320
You might see this, which is actually
really similar to you from printf

514
00:25:03,320 --> 00:25:05,490
but it's deprecated in Python 3.

515
00:25:05,490 --> 00:25:09,020
So you don't really want to use it even
though it might be more familiar to you

516
00:25:09,020 --> 00:25:11,180
because it's similar to printf.

517
00:25:11,180 --> 00:25:15,000
So you might see it, but try and avoid
using it because it is deprecated.

518
00:25:15,000 --> 00:25:18,500
So again, Python is not
just a main function

519
00:25:18,500 --> 00:25:20,297
that we just run down the lines.

520
00:25:20,297 --> 00:25:22,130
In fact, Python doesn't
have a main function

521
00:25:22,130 --> 00:25:24,500
by default. We have
to explicitly force it

522
00:25:24,500 --> 00:25:26,380
to have a main function if we want to.

523
00:25:26,380 --> 00:25:28,294
But it does support
functions more generally.

524
00:25:28,294 --> 00:25:30,710
And we don't need to specify
the return type of functions.

525
00:25:30,710 --> 00:25:33,400
And we don't need to specify the
data types of any parameters.

526
00:25:33,400 --> 00:25:38,120
So you might recall from C that we
had to specify like int square maybe

527
00:25:38,120 --> 00:25:42,060
it took an integer as its input, so
int square parentheses int x semicolon

528
00:25:42,060 --> 00:25:43,822
or all this stuff we have going on.

529
00:25:43,822 --> 00:25:45,530
We don't have to any
of those data types.

530
00:25:45,530 --> 00:25:48,590
We just have to specify the name
of the function and any parameters

531
00:25:48,590 --> 00:25:49,850
that it takes.

532
00:25:49,850 --> 00:25:52,910
We introduce a function
using the keyword def.

533
00:25:52,910 --> 00:25:56,162
So basically, think about it as like
defining the following function.

534
00:25:56,162 --> 00:25:58,370
And because the interpreter
reads from top to bottom,

535
00:25:58,370 --> 00:26:00,470
we don't have to include
our main function.

536
00:26:00,470 --> 00:26:04,580
But if we want to include main because
maybe we wrote our code such that

537
00:26:04,580 --> 00:26:07,964
the stuff we want to execute
first actually is maybe 200 lines

538
00:26:07,964 --> 00:26:09,880
into our file-- we wrote
other stuff up above,

539
00:26:09,880 --> 00:26:13,070
maybe we're keeping our functions in
alphabetical order or whatever else--

540
00:26:13,070 --> 00:26:18,140
we can explicitly direct our program
to start at the main function

541
00:26:18,140 --> 00:26:22,506
by including this line at the
very, very end of our Python file.

542
00:26:22,506 --> 00:26:24,130
And this is just something to memorize.

543
00:26:24,130 --> 00:26:28,640
If underscore underscore name
underscore underscore equals equals

544
00:26:28,640 --> 00:26:34,280
quote underscore underscore main
underscore underscore quote colon

545
00:26:34,280 --> 00:26:36,351
and then tab in main parentheses.

546
00:26:36,351 --> 00:26:38,600
This is one of those things
that you don't necessarily

547
00:26:38,600 --> 00:26:40,130
have to use because you
write your code such

548
00:26:40,130 --> 00:26:42,088
that the first line is
the first thing you want

549
00:26:42,088 --> 00:26:44,030
to happen it's going to be fine anyway.

550
00:26:44,030 --> 00:26:45,770
But if you write it
out of order, this is

551
00:26:45,770 --> 00:26:47,894
just one of those things
you just have to memorize.

552
00:26:47,894 --> 00:26:49,100
Sorry.

553
00:26:49,100 --> 00:26:51,060
So defining a function,
pretty straightforward.

554
00:26:51,060 --> 00:26:53,390
Let's define the square
of x like we just

555
00:26:53,390 --> 00:26:59,210
did a second ago in C. Def square
parentheses x colon return x times x.

556
00:26:59,210 --> 00:27:00,300
Pretty straightforward.

557
00:27:00,300 --> 00:27:01,230
I could also do this.

558
00:27:01,230 --> 00:27:04,550
I could return x times times 2.

559
00:27:04,550 --> 00:27:08,210
Well, actually this operator here
is a built in, which did not have,

560
00:27:08,210 --> 00:27:09,290
exponentiation operator.

561
00:27:09,290 --> 00:27:11,357
So this is return x squared.

562
00:27:11,357 --> 00:27:13,940
I could also be really convoluted
and write my square function

563
00:27:13,940 --> 00:27:16,174
by adding x to itself x times.

564
00:27:16,174 --> 00:27:17,090
Doesn't really matter.

565
00:27:17,090 --> 00:27:19,805
As long as the result is the
same, it can be a black box

566
00:27:19,805 --> 00:27:21,805
just like we talked about
an out function video.

567
00:27:21,805 --> 00:27:24,809
We don't necessarily care how
the square function is defined,

568
00:27:24,809 --> 00:27:26,600
as long as it does what
we expect it to do.

569
00:27:26,600 --> 00:27:31,456
As long as printing the
square of 5 prints out 25.

570
00:27:31,456 --> 00:27:34,260
All right, now here's
something entirely different.

571
00:27:34,260 --> 00:27:35,970
Let's talk about objects.

572
00:27:35,970 --> 00:27:39,630
So objects we have not
covered yet in CS50.

573
00:27:39,630 --> 00:27:42,300
And Python is an object
oriented programming language.

574
00:27:42,300 --> 00:27:47,130
The closest thing we have to
an object is a C structure.

575
00:27:47,130 --> 00:27:50,820
So C structures, you may recall,
have a number of fields in them.

576
00:27:50,820 --> 00:27:54,330
We might call those fields, particularly
in an object oriented context,

577
00:27:54,330 --> 00:27:55,296
properties.

578
00:27:55,296 --> 00:27:58,420
But those properties are never kind of
able to just be on their own, right?

579
00:27:58,420 --> 00:28:03,220
They're always bound up and tied into
some definition of some C structure.

580
00:28:03,220 --> 00:28:07,200
So if I define in C here, as I do at
the top right, a car structure that

581
00:28:07,200 --> 00:28:12,180
has two fields or two properties
in it, year and model,

582
00:28:12,180 --> 00:28:13,800
I might be able to say the following.

583
00:28:13,800 --> 00:28:17,850
Struct car Herbie-- I'm declaring a
new variable of type struct car called

584
00:28:17,850 --> 00:28:18,800
Herbie--

585
00:28:18,800 --> 00:28:21,780
and I'm saying Herbie
dot year equals 1963,

586
00:28:21,780 --> 00:28:24,720
Herbie dot model equals
beetle, totally OK, right?

587
00:28:24,720 --> 00:28:27,810
Because in each case where
I'm using year and model,

588
00:28:27,810 --> 00:28:32,870
I'm associating it with some structure
of that data type, in this case Herbie.

589
00:28:32,870 --> 00:28:34,230
But I could never say this.

590
00:28:34,230 --> 00:28:39,240
Is not valid in C, at least
with what we have here,

591
00:28:39,240 --> 00:28:42,840
because year and model don't just
kind of hang out on their own.

592
00:28:42,840 --> 00:28:47,340
They're attached to what-- they're part
of what it means to be a struct car.

593
00:28:47,340 --> 00:28:49,620
So we always have to associate
them with a struct car.

594
00:28:49,620 --> 00:28:52,680
So that would not fly.

595
00:28:52,680 --> 00:28:54,450
So that's sort of the--

596
00:28:54,450 --> 00:28:59,347
that's sort of the analogy of object
properties to C structure fields.

597
00:28:59,347 --> 00:29:02,055
But objects, in addition to having
properties, also have methods.

598
00:29:02,055 --> 00:29:06,980
And you've heard me use that word a
couple of times so far in this video.

599
00:29:06,980 --> 00:29:10,710
Methods are basically functions
that are inherent to what

600
00:29:10,710 --> 00:29:11,760
it means to be an object.

601
00:29:11,760 --> 00:29:16,470
You can't call that function just
kind of out of the blue on anything.

602
00:29:16,470 --> 00:29:21,150
You can only call that function
on objects of that type,

603
00:29:21,150 --> 00:29:24,877
on objects where that
function means something.

604
00:29:24,877 --> 00:29:27,210
So properties and methods
don't ever stand on their own.

605
00:29:27,210 --> 00:29:29,790
They're always part of what
it means to be an object.

606
00:29:29,790 --> 00:29:32,970
And because of this, objects
become a lot more important.

607
00:29:32,970 --> 00:29:35,980
If you have these properties
and you have these methods

608
00:29:35,980 --> 00:29:39,900
and they're always dependent on objects,
that's where the term object oriented

609
00:29:39,900 --> 00:29:40,860
comes from.

610
00:29:40,860 --> 00:29:43,150
The object is the most important thing.

611
00:29:43,150 --> 00:29:49,620
We don't pass objects into a
function, we call methods on objects.

612
00:29:49,620 --> 00:29:51,360
And that's the general
syntax that you'll

613
00:29:51,360 --> 00:29:55,480
see in a lot of object oriented
programming languages, is some object,

614
00:29:55,480 --> 00:29:56,940
and there is some method--

615
00:29:56,940 --> 00:29:59,231
which again, is just another
word for a function-- that

616
00:29:59,231 --> 00:30:02,730
is associated with it that we
are calling on that object.

617
00:30:02,730 --> 00:30:05,880
We'll take a look at an example
of this in just a moment.

618
00:30:05,880 --> 00:30:07,670
Now objects are not necessarily generic.

619
00:30:07,670 --> 00:30:10,640
We can actually create our
own specific kinds of objects

620
00:30:10,640 --> 00:30:14,000
just like we created our own
specific types of structures in C.

621
00:30:14,000 --> 00:30:16,820
And the way we do that is
using the class keyword.

622
00:30:16,820 --> 00:30:20,630
The class keyword introduces
a new kind of object.

623
00:30:20,630 --> 00:30:23,630
Every class, so every new
kind of object you create,

624
00:30:23,630 --> 00:30:25,670
requires an initialization function.

625
00:30:25,670 --> 00:30:28,820
We didn't have to do this in
C. But basically what it does--

626
00:30:28,820 --> 00:30:32,420
and you'll also hear this
term as a constructor,

627
00:30:32,420 --> 00:30:35,600
you'll hear that commonly used in
languages like C++ for example--

628
00:30:35,600 --> 00:30:39,620
and basically what it does is it creates
an object for you and it puts some--

629
00:30:39,620 --> 00:30:42,470
it assigns the value of some
properties automatically.

630
00:30:42,470 --> 00:30:45,800
Remember that in Python we
can only declare variables

631
00:30:45,800 --> 00:30:49,420
by assigning them a value.

632
00:30:49,420 --> 00:30:51,660
So basically, this is
the analogous idea.

633
00:30:51,660 --> 00:30:54,940
We are creating an object
of a particular class,

634
00:30:54,940 --> 00:30:57,930
and we are filling in all
or many of the properties

635
00:30:57,930 --> 00:31:01,000
of that object with some data.

636
00:31:01,000 --> 00:31:04,030
Then, in addition to defining
the properties of the object,

637
00:31:04,030 --> 00:31:09,330
we also have to define functions or
methods that can apply to the object.

638
00:31:09,330 --> 00:31:12,984
Every method that we define inside of
the class has at least one parameter,

639
00:31:12,984 --> 00:31:15,900
and that parameter is canonically--
although you don't have to call it

640
00:31:15,900 --> 00:31:16,530
this--

641
00:31:16,530 --> 00:31:20,850
is called self, and basically all
it is is a reference to the object

642
00:31:20,850 --> 00:31:24,310
so that we can always know what
object we are talking about.

643
00:31:24,310 --> 00:31:27,210
So every function that
you write, every method

644
00:31:27,210 --> 00:31:31,440
that you write in a class to
find some new kind of object,

645
00:31:31,440 --> 00:31:34,760
will always have one more
parameter than you think you need,

646
00:31:34,760 --> 00:31:38,030
because the first parameter
there will always be self.

647
00:31:38,030 --> 00:31:41,400
Let's try and distill
this into some actual code

648
00:31:41,400 --> 00:31:44,150
so you can what we're doing here
when we're talking about defining

649
00:31:44,150 --> 00:31:46,320
a new kind of class,
defining some methods,

650
00:31:46,320 --> 00:31:52,410
and then we'll see how we can apply
those methods to objects in that class.

651
00:31:52,410 --> 00:31:57,590
So here is a very simple
class called student.

652
00:31:57,590 --> 00:31:59,842
So class Student with a
capital S-- apparently this

653
00:31:59,842 --> 00:32:03,050
means that I am now going to create--
whenever I want to create a new student

654
00:32:03,050 --> 00:32:06,680
object I'll use that
capital S Student keyword.

655
00:32:06,680 --> 00:32:08,400
And I'm defining three functions.

656
00:32:08,400 --> 00:32:11,180
The first is that constructor,
that initialization function, which

657
00:32:11,180 --> 00:32:15,502
is always called underscore
underscore init underscore underscore.

658
00:32:15,502 --> 00:32:17,960
Now, my Student apparently is
going to have two properties.

659
00:32:17,960 --> 00:32:20,870
They're going to have a name and an ID.

660
00:32:20,870 --> 00:32:23,210
But because I'm defining a
method inside of that class,

661
00:32:23,210 --> 00:32:25,760
I always have to include that
self parameter so that I always

662
00:32:25,760 --> 00:32:30,697
know what object I am talking about
or what object to being invoked here.

663
00:32:30,697 --> 00:32:34,030
Inside of my initialization function I'm
doing something pretty straightforward.

664
00:32:34,030 --> 00:32:38,110
I'm just saying, self dot name equals
name and self dot ID equals ID.

665
00:32:38,110 --> 00:32:43,630
So I'm assigning the name and ID
properties of the Student object

666
00:32:43,630 --> 00:32:45,920
to be whatever I pass in here.

667
00:32:45,920 --> 00:32:48,110
And then I have another
function called changeID,

668
00:32:48,110 --> 00:32:51,830
and apparently I use
this to change the idea

669
00:32:51,830 --> 00:32:55,622
of a student, the ID number of a
student after I've already created them.

670
00:32:55,622 --> 00:32:58,080
Because I'm assigning the ID
when I initialize it, but here

671
00:32:58,080 --> 00:33:00,440
apparently I've already
created the Student object

672
00:33:00,440 --> 00:33:02,030
and I'm going to change it.

673
00:33:02,030 --> 00:33:04,730
So changeID takes two
parameter, self against so I

674
00:33:04,730 --> 00:33:09,520
know which Student, which capital
S Student object I'm talking about,

675
00:33:09,520 --> 00:33:13,170
and the ID number that I
want to change them to.

676
00:33:13,170 --> 00:33:16,981
And then I have a function called print,
which takes just one parameter, self.

677
00:33:16,981 --> 00:33:18,980
It's apparently not going
to take anything else,

678
00:33:18,980 --> 00:33:23,540
but still I always have to
indicate the self parameter.

679
00:33:23,540 --> 00:33:27,360
Always has to be part of any
methods that you define for a class

680
00:33:27,360 --> 00:33:28,400
that you create.

681
00:33:28,400 --> 00:33:32,300
And apparently what I'm doing here is
printing out self dot name and self dot

682
00:33:32,300 --> 00:33:34,080
ID with a little dash between them.

683
00:33:34,080 --> 00:33:35,330
That's what's happening there.

684
00:33:35,330 --> 00:33:38,060
It's just some variable interpolation
just like we saw before.

685
00:33:38,060 --> 00:33:42,560
I'm just printing out self
dot name dash self dot ID.

686
00:33:42,560 --> 00:33:45,080
So what would happen here?

687
00:33:45,080 --> 00:33:49,310
So I'm creating a new variable,
a new object, called Jane.

688
00:33:49,310 --> 00:33:51,219
And this is my initialization.

689
00:33:51,219 --> 00:33:52,760
I'm calling the constructor function.

690
00:33:52,760 --> 00:33:56,470
Jane equals Student with a capital S,
again, that's the name of our class,

691
00:33:56,470 --> 00:33:57,920
and I'm passing in tow values.

692
00:33:57,920 --> 00:34:02,719
Jane, which I apparently want
to map to self dot name, and 10.

693
00:34:02,719 --> 00:34:04,760
So immediately after this,
what would happened is

694
00:34:04,760 --> 00:34:10,159
I would have a new student
object called Jane,

695
00:34:10,159 --> 00:34:14,120
and Jane's name field
would be Jane in quotes,

696
00:34:14,120 --> 00:34:16,500
and Jane's ID field would be 10.

697
00:34:16,500 --> 00:34:17,526
So if I printed it out--

698
00:34:17,526 --> 00:34:20,150
and you can actually take this
code and recreate it in CS50 IDE

699
00:34:20,150 --> 00:34:22,489
and see it for yourself--
if I then printed it out,

700
00:34:22,489 --> 00:34:26,840
I would print out Jane
space dash space 10.

701
00:34:26,840 --> 00:34:30,260
Then if I executed Jane
dot changeID 11, you

702
00:34:30,260 --> 00:34:33,800
can probably guess what would happen
because then when I print it again

703
00:34:33,800 --> 00:34:38,360
it would print Jane space dash space 11.

704
00:34:38,360 --> 00:34:42,620
So that's just some examples of
creating-- of defining a class,

705
00:34:42,620 --> 00:34:45,310
defining methods, assigning properties.

706
00:34:45,310 --> 00:34:47,552
Again, all of this sort
of is inherent to what

707
00:34:47,552 --> 00:34:50,510
it means in an object-- to be working
in an object oriented programming

708
00:34:50,510 --> 00:34:51,389
language.

709
00:34:51,389 --> 00:34:54,659
So even though this may be
very unfamiliar and new,

710
00:34:54,659 --> 00:34:58,340
especially coming from a language
like C, this, if you go forward and do

711
00:34:58,340 --> 00:35:00,560
object oriented programming
in languages like Python,

712
00:35:00,560 --> 00:35:03,320
like PHP, like JavaScript,
or like many, many others,

713
00:35:03,320 --> 00:35:06,290
this sort of notion of
methods, properties,

714
00:35:06,290 --> 00:35:11,171
and how we work with them is going to be
really important to sort of synthesize.

715
00:35:11,171 --> 00:35:13,520
So if you haven't noticed
by now, good style

716
00:35:13,520 --> 00:35:15,610
is really, really important in Python.

717
00:35:15,610 --> 00:35:18,080
We don't have curly braces
anymore which is great,

718
00:35:18,080 --> 00:35:22,670
but we still need to be able
to then indicate when a--

719
00:35:22,670 --> 00:35:25,130
how an if block is delimited.

720
00:35:25,130 --> 00:35:27,740
In C, we had an open curly
brace, then we had some code,

721
00:35:27,740 --> 00:35:29,031
we had some closed curly brace.

722
00:35:29,031 --> 00:35:31,910
And it didn't really matter how
things were styled in between.

723
00:35:31,910 --> 00:35:34,520
I mean it mattered for somebody
who is reading your code,

724
00:35:34,520 --> 00:35:36,250
but it doesn't matter to the computer.

725
00:35:36,250 --> 00:35:37,580
It does matter in Python.

726
00:35:37,580 --> 00:35:42,620
Tabs and indentation are key in order to
indicate what you intend for it to do.

727
00:35:42,620 --> 00:35:45,650
So if I had an if block and I
put a colon at the end of it

728
00:35:45,650 --> 00:35:48,890
and I didn't indent the
next line in, Python

729
00:35:48,890 --> 00:35:54,230
wouldn't know that that line is supposed
to be subject to that if condition.

730
00:35:54,230 --> 00:36:00,240
So if you have not yet been in the
habit of practicing good coding style,

731
00:36:00,240 --> 00:36:04,700
now is the time to definitely reacquaint
yourself with the CS50 style guide,

732
00:36:04,700 --> 00:36:08,360
because if your code in
Python is poorly styled,

733
00:36:08,360 --> 00:36:11,250
it's probably not going to work.

734
00:36:11,250 --> 00:36:14,220
Sorry about that.

735
00:36:14,220 --> 00:36:16,180
So in C, we had the
notion of including files

736
00:36:16,180 --> 00:36:19,530
if we needed to get additional
information from libraries,

737
00:36:19,530 --> 00:36:21,800
for example like standard
IO or CS50 dot h.

738
00:36:21,800 --> 00:36:24,710
We can do the same thing in
Python and C it was pound include.

739
00:36:24,710 --> 00:36:28,580
In Python, we import, and instead of
being called header files or libraries,

740
00:36:28,580 --> 00:36:30,500
we generally call them modules.

741
00:36:30,500 --> 00:36:34,580
But we could import CD50, and if we
do we could then call some of the CD50

742
00:36:34,580 --> 00:36:36,330
functions we might be familiar with.

743
00:36:36,330 --> 00:36:39,950
We can do that by saying for example,
CD50 dot get int parentheses.

744
00:36:39,950 --> 00:36:45,090
And that would, just like get int does
in C, get an integer from the user.

745
00:36:45,090 --> 00:36:47,840
CS50 dot get float, dot
get string, dot get char.

746
00:36:47,840 --> 00:36:52,606
All those things that you've used in
C, we can still use them in Python.

747
00:36:52,606 --> 00:36:54,230
They just take a little longer to type.

748
00:36:54,230 --> 00:37:01,060
We have to specify CS50 dot, because
CS50 is basically, not exactly,

749
00:37:01,060 --> 00:37:03,110
but it's basically a
class where we're defining

750
00:37:03,110 --> 00:37:09,570
a couple of different methods
within it that we can then invoke.

751
00:37:09,570 --> 00:37:13,710
You can, in addition to pre-writing
your files in dot py files,

752
00:37:13,710 --> 00:37:17,087
you can also just literally write
Python using the Python interpreter

753
00:37:17,087 --> 00:37:17,920
at the command line.

754
00:37:17,920 --> 00:37:22,980
You can type in your IDE or in a lot of
environments Python, and then hit Enter

755
00:37:22,980 --> 00:37:25,260
and it will open a Python interpreter.

756
00:37:25,260 --> 00:37:27,522
And you can literally write
Python one line at a time.

757
00:37:27,522 --> 00:37:30,480
In general though, if you're going
to be writing more complex programs,

758
00:37:30,480 --> 00:37:33,229
you're probably going to want to
pre-write them and then load them

759
00:37:33,229 --> 00:37:35,130
into the Python interpreter instead.

760
00:37:35,130 --> 00:37:37,860
To invoke the Python interpreter,
particular in CS50 IDE

761
00:37:37,860 --> 00:37:41,790
but again more generally, Python space
whatever the file you want to invoke

762
00:37:41,790 --> 00:37:44,940
is, and then what will happen is
the interpreter will open that file

763
00:37:44,940 --> 00:37:50,280
and proceed one line at a time, top
to bottom, executing your Python code.

764
00:37:50,280 --> 00:37:54,870
And if you really want to make your
Python programs look and run a lot more

765
00:37:54,870 --> 00:37:58,950
like C programs-- for example, in
C, once we compile a program into--

766
00:37:58,950 --> 00:38:01,410
say we make hello, we then
have dot slash hello--

767
00:38:01,410 --> 00:38:06,000
we can include this line in red at
the very top of our Python file.

768
00:38:06,000 --> 00:38:10,890
And then we can execute the line in
blue after we're done saving the file.

769
00:38:10,890 --> 00:38:13,440
And then we can actually instead
of typing Python and then

770
00:38:13,440 --> 00:38:16,670
some whatever we want to call it dot
pie, we could then just write dot

771
00:38:16,670 --> 00:38:20,640
slash blah blah blah dot pie.

772
00:38:20,640 --> 00:38:24,360
So again, I know that was a long video,
there was a lot to cover in that one.

773
00:38:24,360 --> 00:38:28,950
And we've really only just scratched the
surface of introducing you to Python.

774
00:38:28,950 --> 00:38:32,072
But it is an amazing
language, incredibly flexible,

775
00:38:32,072 --> 00:38:35,030
and it's a tool you're really going
to want to put in your programmer's

776
00:38:35,030 --> 00:38:39,160
toolbox if you're ever doing anything
like data science or complex string

777
00:38:39,160 --> 00:38:41,910
manipulation or really just
familiarizing yourself with a language

778
00:38:41,910 --> 00:38:45,352
that you can use both at the command
line and in a web development context.

779
00:38:45,352 --> 00:38:48,310
And we'll talk about how we can use
Python in a web development context

780
00:38:48,310 --> 00:38:50,810
in another video on flask.

781
00:38:50,810 --> 00:38:53,980
I'm Doug Lloyd, this is CS50.

782
00:38:53,980 --> 00:38:55,206